using System.Diagnostics;
using Azure.Storage.Blobs;
using PwaApp.Application.Interfaces;

namespace backend.Services
{

    public class Mp4HlsConversionStrategy(IAzureBlobService azureBlobService) : IFileConversionStrategy
    {
        public bool CanHandle(string mimeType)
        {
            return mimeType == "video/mp4";
        }

        public async Task ConvertAsync(string localDirectory, WebApplication1.File file, Guid userId)
        {
            //download video file from azure to temp directory
            var blobName = azureBlobService.BuildUserScopedBlobName(userId, file.id, file.FileName);
            var targetDirectory = Path.GetDirectoryName(blobName);

            await azureBlobService.DonwloadFileToDirectory(blobName, localDirectory, file.FileName);

            var filesDirectory = Path.Combine(localDirectory, "files");

            string ffmpegPath = "ffmpeg";

            if (!Directory.Exists(filesDirectory))
            {
                Directory.CreateDirectory(filesDirectory);
            }

            var versions = new[]
            {
                new { Name = "1080p", Width = 1920, Height = 1080, Bitrate = 5000000},
                new { Name = "720p", Width = 1280, Height = 720, Bitrate = 2800000},
                new { Name = "480p", Width = 854, Height = 480, Bitrate = 1400000}
            };

            var inputFile = Path.Combine(localDirectory, file.FileName);
            
            // Get CPU thread count for optimal parallel processing
            var threadCount = Environment.ProcessorCount;

            //create .ts segments and .m3u8 files in parallel
            var conversionTasks = versions.Select(async version =>
            {
                string args = $"-i \"{inputFile}\" -vf scale=w={version.Width}:h={version.Height} " +
                               $"-c:a aac -ar 48000 -c:v h264 -profile:v main -preset fast -crf 22 -sc_threshold 0 " +
                               $"-threads {threadCount} -g 48 -keyint_min 48 -hls_time 4 -hls_playlist_type vod " +
                               $"-hls_segment_filename \"{Path.Combine(filesDirectory, version.Name)}_%03d.ts\" " +
                               $"{Path.Combine(filesDirectory, version.Name)}.m3u8 " +
                               $"-b:v {version.Bitrate}";
                await RunProcessAsync(ffmpegPath, args);
            });

            // Wait for all conversions to complete in parallel
            await Task.WhenAll(conversionTasks);

            //creating .m3u8 playlist
            string masterPlaylist = Path.Combine(filesDirectory, "master.m3u8");
            using (var sw = new StreamWriter(masterPlaylist, false))
            {
                sw.WriteLine("#EXTM3U");
                sw.WriteLine("#EXT-X-VERSION:3");

                foreach (var version in versions)
                {
                    sw.WriteLine($"#EXT-X-STREAM-INF:BANDWIDTH={version.Bitrate},RESOLUTION={version.Width}x{version.Height}");
                    sw.WriteLine($"{version.Name}.m3u8");
                }
            }

            //upload files from /temp directory to azure in parallel
            await UploadAllFilesAsync(filesDirectory, targetDirectory);
        }

        private static async Task RunProcessAsync(string exePath, string arguments)
        {
            var tcs = new TaskCompletionSource<int>();
            var process = new Process();
            process.StartInfo.FileName = exePath;
            process.StartInfo.Arguments = arguments;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;

            //printing logs generated by ffmpeg
            process.OutputDataReceived += (s, e) => { if (e.Data != null) Console.WriteLine(e.Data); };
            process.ErrorDataReceived += (s, e) => { if (e.Data != null) Console.WriteLine(e.Data); };
            
            process.Exited += (s, e) => tcs.SetResult(process.ExitCode);

            process.Start();
            process.BeginOutputReadLine();
            process.BeginErrorReadLine();

            var exitCode = await tcs.Task;
            
            if (exitCode != 0)
            {
                throw new Exception($"FFmpeg process failed with exit code {exitCode}. Arguments: {arguments}");
            }
        }

        private async Task UploadAllFilesAsync(string sourceDirectory, string targetDirectory)
        {
            var files = Directory.GetFiles(sourceDirectory);
            var uploadTasks = files.Select(async file =>
            {
                string blobName = Path.GetFileName(file);
                await azureBlobService.UploadFileAsync(blobName, file, targetDirectory);
            });

            // Upload all files in parallel
            await Task.WhenAll(uploadTasks);
        }
    }
}

